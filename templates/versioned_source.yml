name: Versioned source
runs-on: ${{ fromJSON(inputs.runs_on) }}
timeout-minutes: ${{ fromJSON(inputs.jobs_timeout_minutes) }}
needs: [event_types, project_types]

defaults:
  run:
    working-directory: .
    shell: bash --noprofile --norc -eo pipefail -x {0}

outputs:
  new_tag: ${{ steps.new_version.outputs.tag || steps.git_describe.outputs.tag }}
  version: ${{ steps.new_version.outputs.semver }}

steps:
  - name: Checkout source
    uses: actions/checkout@v3
    with:
      fetch-depth: 0
      submodules: "recursive"
      token: ${{ secrets.FLOWZONE_TOKEN }}

  - name: Import GPG key for signing commits
    if: inputs.disable_versioning != true && github.event_name == 'pull_request'
    id: import-gpg
    uses: crazy-max/ghaction-import-gpg@v4
    with:
      gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
      passphrase: ${{ secrets.GPG_PASSPHRASE }}
      git_config_global: true
      git_user_signingkey: true
      git_commit_gpgsign: true

  - name: Install versionist
    if: inputs.disable_versioning != true && github.event_name == 'pull_request'
    run: |
      npm install -g balena-versionist@0.14.10 versionist@6.8.4

  - name: Generate changelog
    if: inputs.disable_versioning != true && github.event_name == 'pull_request'
    run: |
      if [ ! -f .versionbot/CHANGELOG.yml ]
      then
        (cd ${{ runner.temp }}

        wget https://github.com/mikefarah/yq/releases/download/3.0.1/yq_linux_amd64 -O yq
        echo "a1097c74b81a2ef255583d9718bf4be6  yq" | md5sum -c -
        chmod +x yq

        PATH="${PWD}:${PATH}" GH_TOKEN=${{ secrets.FLOWZONE_TOKEN }} $(npm root -g)/versionist/scripts/generate-changelog.sh "${GITHUB_WORKSPACE}"
        )
      fi

  # parse last versioned commit from tags so we can check for changes
  # this step can fail if there has never been a versioned PR merged
  - name: Get latest tag for current branch
    continue-on-error: true
    id: old_version
    if: inputs.disable_versioning != true && github.event_name == 'pull_request'
    run: |
      tag="$(git tag --list --sort=-version:refname "v*.*.*" --merged | head -n1)"
      echo "semver=${tag/v/}" >> $GITHUB_OUTPUT
      echo "tag=${tag}" >> $GITHUB_OUTPUT

  # install and run versionist via balena-versionist
  - name: Run versionist
    if: inputs.disable_versioning != true && github.event_name == 'pull_request'
    run: |
      balena-versionist

  # set a tag to be used as a fallback if versioning is disabled
  - name: Git describe
    id: git_describe
    run: echo "tag=$(git describe --tags --always --dirty)" >> $GITHUB_OUTPUT

  # inspect all known versioned files to extract the new version
  # TODO: versionist should provide the new version via stdout!
  - name: Inspect versioned files
    id: new_version
    if: inputs.disable_versioning != true && github.event_name == 'pull_request'
    run: |
      git status --porcelain
      versions=()
      [ -f .versionbot/CHANGELOG.yml ] && versions+=($(yq e '.[0].version' .versionbot/CHANGELOG.yml))
      semver="${versions[0]}"
      if [ -z "${semver}" ] || [ "${semver}" = "${{ steps.old_version.outputs.semver }}" ]
      then
        echo "::error::Failed to detect any versioned files! Did you include a Change-type?"
        exit 1
      fi

      echo "semver=${semver}" >> $GITHUB_OUTPUT
      echo "tag=v${semver}" >> $GITHUB_OUTPUT

  # create a versioned commit
  - name: Create versioned commit
    if: inputs.disable_versioning != true
    env:
      GIT_AUTHOR_NAME: ${{ steps.import-gpg.outputs.name }}
      GIT_AUTHOR_EMAIL: ${{ steps.import-gpg.outputs.email }}
      GIT_COMMITTER_NAME: ${{ steps.import-gpg.outputs.name }}
      GIT_COMMITTER_EMAIL: ${{ steps.import-gpg.outputs.email }}
      TAG: ${{ steps.new_version.outputs.tag }}
    run: |
      git add --all
      git commit -m "${TAG}"
      git tag -a "${TAG}" -m "${TAG}" -f
      git show -1
      git log -n 2

  # push the versioned commit only if the PR is merged
  - name: Push versioned commit
    if: inputs.disable_versioning != true && needs.event_types.outputs.pr_merged == 'true'
    run: |
      git push origin HEAD:${{ github.base_ref }}
      # We push the tag separately so that it is only pushed if the commit push succeed, this avoids
      # issues if something else updates the main branch whilst we're running and causes us to push
      # the tag successfully but not the main branch and breaks future versioning attempts
      git push origin "refs/tags/${{ steps.new_version.outputs.tag }}"

  # https://github.com/actions/upload-artifact#maintaining-file-permissions-and-case-sensitive-files
  - name: Compress source
    run: tar -acvf ${{ runner.temp }}/source.tgz .

  - name: Upload artifact
    uses: actions/upload-artifact@v3
    with:
      name: source-${{ github.event.pull_request.head.sha || github.event.head_commit.id }}
      path: ${{ runner.temp }}/source.tgz
      retention-days: 1
